use rquickjs::{Context, Runtime, Value};
use std::time::{Duration, Instant};

use super::mocks::SANDBOX_PRELUDE;
use super::trace::SandboxResult;

/// Execute JavaScript code in an isolated QuickJS runtime
pub fn run_in_sandbox(code: &str, timeout_ms: u64) -> SandboxResult {
    // Create runtime with memory limit
    let runtime = match Runtime::new() {
        Ok(rt) => rt,
        Err(e) => return SandboxResult::with_error(format!("Failed to create runtime: {}", e)),
    };

    // Set memory limit (16MB should be plenty for deobfuscation)
    runtime.set_memory_limit(16 * 1024 * 1024);

    // Create context with full intrinsics
    let context = match Context::full(&runtime) {
        Ok(ctx) => ctx,
        Err(e) => return SandboxResult::with_error(format!("Failed to create context: {}", e)),
    };

    let start = Instant::now();
    let timeout = Duration::from_millis(timeout_ms);

    // Set up interrupt handler for timeout
    runtime.set_interrupt_handler(Some(Box::new(move || start.elapsed() > timeout)));

    context.with(|ctx| {
        // Run the prelude to set up mocks
        if let Err(e) = ctx.eval::<(), _>(SANDBOX_PRELUDE) {
            return SandboxResult::with_error(format!("Prelude error: {}", e));
        }

        // Run the user code, capturing the final value
        let user_result: Result<Value, _> = ctx.eval(code);

        let final_value = match &user_result {
            Ok(val) => value_to_string(val),
            Err(_) => None,
        };

        // Get the trace
        let trace_result: Result<String, _> = ctx.eval("__getTrace()");

        let mut result = match trace_result {
            Ok(json) => parse_trace(&json),
            Err(e) => SandboxResult::with_error(format!("Failed to get trace: {}", e)),
        };

        // Set final value
        result.final_value = final_value;

        // Check if we had an error (but still return partial results)
        if let Err(e) = user_result {
            let error_msg = format!("{}", e);
            // Check if execution was interrupted (timeout)
            // QuickJS reports this as "Exception generated by QuickJS" when interrupt handler fires
            if error_msg.contains("interrupted")
                || (start.elapsed() > timeout && error_msg.contains("Exception"))
            {
                result.error =
                    Some(format!("Timeout after {}ms (possible infinite loop)", timeout_ms));
            } else if result.error.is_none() {
                result.error = Some(error_msg);
            }
        }

        result
    })
}

/// Convert a QuickJS Value to an optional String
fn value_to_string(val: &Value) -> Option<String> {
    if val.is_undefined() || val.is_null() {
        return None;
    }

    if let Some(s) = val.as_string() {
        return s.to_string().ok();
    }

    if let Some(n) = val.as_int() {
        return Some(n.to_string());
    }

    if let Some(n) = val.as_float() {
        return Some(n.to_string());
    }

    if let Some(b) = val.as_bool() {
        return Some(b.to_string());
    }

    // For objects/arrays, try to stringify - not easily done without ctx
    None
}

/// Parse the JSON trace from JavaScript
fn parse_trace(json: &str) -> SandboxResult {
    #[derive(serde::Deserialize)]
    struct JsTrace {
        decoded: Vec<JsDecoded>,
        calls: Vec<JsCall>,
    }

    #[derive(serde::Deserialize)]
    struct JsDecoded {
        function: String,
        input: String,
        output: String,
    }

    #[derive(serde::Deserialize)]
    struct JsCall {
        function: String,
        arguments: Vec<serde_json::Value>,
    }

    match serde_json::from_str::<JsTrace>(json) {
        Ok(trace) => SandboxResult {
            decoded_strings: trace
                .decoded
                .into_iter()
                .map(|d| super::trace::DecodedString {
                    function: d.function,
                    input: d.input,
                    output: d.output,
                })
                .collect(),
            api_calls: trace
                .calls
                .into_iter()
                .map(|c| super::trace::ApiCall {
                    function: c.function,
                    arguments: c.arguments,
                })
                .collect(),
            final_value: None,
            error: None,
        },
        Err(e) => SandboxResult::with_error(format!("Failed to parse trace: {}", e)),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_execution() {
        let result = run_in_sandbox("1 + 2", 1000);
        assert!(result.error.is_none(), "Error: {:?}", result.error);
        assert_eq!(result.final_value, Some("3".to_string()));
    }

    #[test]
    fn test_atob_tracing() {
        let result = run_in_sandbox("atob('aGVsbG8=')", 1000);
        assert!(result.error.is_none(), "Error: {:?}", result.error);
        // The prelude's fallback base64 decode uses String.fromCharCode internally,
        // so we may get multiple decoded strings. Check that atob is among them.
        let atob_decode = result
            .decoded_strings
            .iter()
            .find(|d| d.function == "atob");
        assert!(
            atob_decode.is_some(),
            "Expected atob decode, got: {:?}",
            result.decoded_strings
        );
        let atob_decode = atob_decode.unwrap();
        assert_eq!(atob_decode.input, "aGVsbG8=");
        assert_eq!(atob_decode.output, "hello");
    }

    #[test]
    fn test_fetch_tracing() {
        let result = run_in_sandbox("fetch('https://evil.com/data')", 1000);
        assert!(result.error.is_none(), "Error: {:?}", result.error);
        assert_eq!(result.api_calls.len(), 1);
        assert_eq!(result.api_calls[0].function, "fetch");
    }

    #[test]
    fn test_chrome_api_tracing() {
        let result = run_in_sandbox("chrome.cookies.getAll({})", 1000);
        assert!(result.error.is_none(), "Error: {:?}", result.error);
        assert!(result
            .api_calls
            .iter()
            .any(|c| c.function.contains("chrome.cookies")));
    }

    #[test]
    fn test_timeout_protection() {
        let result = run_in_sandbox("while(true) {}", 100);
        assert!(
            result.error.is_some(),
            "Expected an error for infinite loop, got: {:?}",
            result
        );
        let error = result.error.as_ref().unwrap();
        assert!(
            error.contains("Timeout")
                || error.contains("interrupted")
                || error.contains("Interrupt")
                || error.contains("Exception"),
            "Expected timeout/interrupt error, got: {}",
            error
        );
    }

    #[test]
    fn test_syntax_error_handling() {
        let result = run_in_sandbox("this is not valid javascript {{{", 1000);
        assert!(result.error.is_some());
    }

    #[test]
    fn test_string_from_char_code_tracing() {
        let result = run_in_sandbox("String.fromCharCode(104, 101, 108, 108, 111)", 1000);
        assert!(result.error.is_none(), "Error: {:?}", result.error);
        assert!(result
            .decoded_strings
            .iter()
            .any(|d| d.function == "String.fromCharCode" && d.output == "hello"));
    }

    #[test]
    fn test_localstorage_tracing() {
        let result = run_in_sandbox("localStorage.setItem('key', 'value')", 1000);
        assert!(result.error.is_none(), "Error: {:?}", result.error);
        assert!(result
            .api_calls
            .iter()
            .any(|c| c.function == "localStorage.setItem"));
    }
}
